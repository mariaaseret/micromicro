CCS PCM C Compiler, Version 5.008, 5967               13-jun-17 19:28

               Filename:   C:\Users\Maria Teresa\Desktop\ProjetoMaria\main.lst

               ROM used:   2028 words (25%)
                           Largest free fragment is 2048
               RAM used:   23 (6%) at main() level
                           37 (10%) worst case
               Stack used: 6 locations (5 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  04
0001:  MOVWF  0A
0002:  GOTO   471
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.0
001A:  GOTO   01D
001B:  BTFSC  0C.0
001C:  GOTO   02E
001D:  MOVF   22,W
001E:  MOVWF  04
001F:  MOVF   23,W
0020:  MOVWF  77
0021:  MOVF   24,W
0022:  MOVWF  78
0023:  MOVF   25,W
0024:  MOVWF  79
0025:  MOVF   26,W
0026:  MOVWF  7A
0027:  MOVF   20,W
0028:  MOVWF  0A
0029:  SWAPF  21,W
002A:  MOVWF  03
002B:  SWAPF  7F,F
002C:  SWAPF  7F,W
002D:  RETFIE
002E:  BCF    0A.3
002F:  BCF    0A.4
0030:  GOTO   039
.................... /* 
....................  * Arquivo:   main.c 
....................  * Autor: Maria Teresa 
....................  * Criado em 06 de Junho de 2017 
....................  * Obejetivo: Projeto final da disciplina 
....................  */ 
....................  
.................... #include <main.h> 
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
0031:  BCF    0A.0
0032:  BCF    0A.1
0033:  BCF    0A.2
0034:  ADDWF  02,F
0035:  RETLW  28
0036:  RETLW  0C
0037:  RETLW  01
0038:  RETLW  06
*
004C:  DATA 45,37
004D:  DATA 63,34
004E:  DATA 65,37
004F:  DATA E4,37
0050:  DATA 20,10
0051:  DATA 20,10
0052:  DATA 20,10
0053:  DATA 0A,00
0054:  DATA 31,1D
0055:  DATA CF,25
0056:  DATA 20,10
0057:  DATA 20,10
0058:  DATA 20,10
0059:  DATA 0A,00
005A:  DATA C6,34
005B:  DATA 6C,3A
005C:  DATA F2,30
005D:  DATA 6E,32
005E:  DATA 6F,10
005F:  DATA 20,10
0060:  DATA A5,3A
0061:  DATA 20,10
0062:  DATA 20,05
0063:  DATA 00,00
0064:  DATA BD,1E
0065:  DATA C6,24
0066:  DATA CD,1E
0067:  DATA 3D,10
0068:  DATA 20,10
0069:  DATA 20,10
006A:  DATA 8A,20
006B:  DATA CD,20
006C:  DATA 4E,24
006D:  DATA 41,10
006E:  DATA D4,22
006F:  DATA 4D,10
0070:  DATA CD,20
0071:  DATA C9,29
0072:  DATA 00,01
0073:  DATA C6,34
0074:  DATA 6C,3A
0075:  DATA F2,30
0076:  DATA 6E,32
0077:  DATA 6F,10
0078:  DATA A0,12
0079:  DATA 75,10
007A:  DATA 20,10
007B:  DATA 0A,00
007C:  DATA 31,1D
007D:  DATA CF,25
007E:  DATA 2C,10
007F:  DATA 32,1D
0080:  DATA CF,25
0081:  DATA 20,10
0082:  DATA 20,10
0083:  DATA 20,05
0084:  DATA 00,01
0085:  DATA 41,38
0086:  DATA EC,34
0087:  DATA 63,10
0088:  DATA 41,36
0089:  DATA E7,34
008A:  DATA E3,34
008B:  DATA E4,30
008C:  DATA 20,10
008D:  DATA A5,3A
008E:  DATA 20,10
008F:  DATA 20,05
0090:  DATA 00,01
0091:  DATA 31,1D
0092:  DATA CF,25
0093:  DATA 2C,10
0094:  DATA 32,1D
0095:  DATA CF,25
0096:  DATA 2C,10
0097:  DATA 33,1D
0098:  DATA CF,25
0099:  DATA 20,10
009A:  DATA 20,10
009B:  DATA 0A,00
009C:  DATA CC,22
009D:  DATA 4E,22
009E:  DATA 4F,10
009F:  DATA D3,22
00A0:  DATA CE,29
00A1:  DATA 4F,29
00A2:  DATA A0,20
00A3:  DATA 54,10
00A4:  DATA 20,05
00A5:  DATA 00,01
00A6:  DATA 41,2A
00A7:  DATA A0,24
00A8:  DATA C4,22
00A9:  DATA 41,26
00AA:  DATA 3A,10
00AB:  DATA A0,12
00AC:  DATA 75,10
00AD:  DATA 20,10
00AE:  DATA 0A,00
00AF:  DATA 31,1D
00B0:  DATA CF,25
00B1:  DATA 2C,10
00B2:  DATA 32,1D
00B3:  DATA CF,25
00B4:  DATA 2C,10
00B5:  DATA 33,1D
00B6:  DATA CF,25
00B7:  DATA 2C,10
00B8:  DATA 20,05
00B9:  DATA 20,1A
00BA:  DATA BA,27
00BB:  DATA 4B,00
00BC:  DATA 41,2A
00BD:  DATA 20,21
00BE:  DATA C1,24
00BF:  DATA D8,20
00C0:  DATA 3A,10
00C1:  DATA A0,12
00C2:  DATA 75,10
00C3:  DATA 20,10
00C4:  DATA 0A,00
00C5:  DATA 41,2A
00C6:  DATA A0,20
00C7:  DATA 4C,2A
00C8:  DATA 41,1D
00C9:  DATA 20,10
00CA:  DATA A5,3A
00CB:  DATA 20,10
00CC:  DATA 20,05
00CD:  DATA 00,01
00CE:  DATA CC,22
00CF:  DATA 4E,22
00D0:  DATA 4F,10
00D1:  DATA D3,22
00D2:  DATA CE,29
00D3:  DATA 4F,29
00D4:  DATA 20,28
00D5:  DATA 48,10
00D6:  DATA 20,05
00D7:  DATA 00,01
00D8:  DATA 50,24
00D9:  DATA 20,21
00DA:  DATA C1,24
00DB:  DATA D8,27
00DC:  DATA 3A,10
00DD:  DATA A0,12
00DE:  DATA 75,10
00DF:  DATA 20,10
00E0:  DATA 0A,00
00E1:  DATA 50,24
00E2:  DATA A0,24
00E3:  DATA C4,22
00E4:  DATA 41,26
00E5:  DATA 3A,10
00E6:  DATA A0,12
00E7:  DATA 75,10
00E8:  DATA 20,10
00E9:  DATA 0A,00
00EA:  DATA 31,1D
00EB:  DATA CF,25
00EC:  DATA 2C,10
00ED:  DATA 32,1D
00EE:  DATA CF,25
00EF:  DATA 2C,10
00F0:  DATA 33,1D
00F1:  DATA CF,25
00F2:  DATA 2C,10
00F3:  DATA 20,10
00F4:  DATA 0A,10
00F5:  DATA 20,1A
00F6:  DATA BA,27
00F7:  DATA 4B,16
00F8:  DATA A0,1A
00F9:  DATA BA,27
00FA:  DATA 4B,10
00FB:  DATA 00,01
00FC:  DATA 50,24
00FD:  DATA A0,20
00FE:  DATA 4C,2A
00FF:  DATA 4F,1D
0100:  DATA 20,10
0101:  DATA A5,3A
0102:  DATA 20,10
0103:  DATA 20,05
0104:  DATA 00,01
0105:  DATA 43,26
0106:  DATA 4F,29
0107:  DATA 4F,10
0108:  DATA 49,22
0109:  DATA C5,20
010A:  DATA 4C,1D
010B:  DATA 20,10
010C:  DATA A5,3A
010D:  DATA 20,10
010E:  DATA 20,05
010F:  DATA 00,01
0110:  DATA 31,1D
0111:  DATA CF,25
0112:  DATA 2C,10
0113:  DATA 32,1D
0114:  DATA CF,25
0115:  DATA 2C,10
0116:  DATA 33,1D
0117:  DATA CF,25
0118:  DATA 2C,10
0119:  DATA 20,10
011A:  DATA 0A,1A
011B:  DATA BA,27
011C:  DATA 4B,16
011D:  DATA A0,1A
011E:  DATA BA,27
011F:  DATA 4B,16
0120:  DATA 20,1B
0121:  DATA BA,27
0122:  DATA 4B,10
0123:  DATA 00,01
0124:  DATA 41,28
0125:  DATA CC,24
0126:  DATA D1,2A
0127:  DATA 45,10
0128:  DATA CD,20
0129:  DATA C9,29
012A:  DATA A0,21
012B:  DATA CC,27
012C:  DATA D2,27
012D:  DATA 3A,10
012E:  DATA A0,12
012F:  DATA 75,10
0130:  DATA 20,10
0131:  DATA 0A,00
*
0247:  MOVF   0B,W
0248:  MOVWF  31
0249:  BCF    0B.7
024A:  BSF    03.5
024B:  BSF    03.6
024C:  BSF    0C.7
024D:  BSF    0C.0
024E:  NOP
024F:  NOP
0250:  BCF    03.5
0251:  MOVF   0C,W
0252:  ANDLW  7F
0253:  BTFSC  03.2
0254:  GOTO   28E
0255:  BCF    03.6
0256:  MOVWF  32
0257:  BSF    03.6
0258:  MOVF   0D,W
0259:  BCF    03.6
025A:  MOVWF  33
025B:  BSF    03.6
025C:  MOVF   0F,W
025D:  BCF    03.6
025E:  MOVWF  34
025F:  MOVF   32,W
0260:  MOVWF  36
0261:  CALL   215
0262:  MOVF   33,W
0263:  BSF    03.6
0264:  MOVWF  0D
0265:  BCF    03.6
0266:  MOVF   34,W
0267:  BSF    03.6
0268:  MOVWF  0F
0269:  BSF    03.5
026A:  BSF    0C.7
026B:  BSF    0C.0
026C:  NOP
026D:  NOP
026E:  BCF    03.5
026F:  RLF    0C,W
0270:  RLF    0E,W
0271:  ANDLW  7F
0272:  BTFSC  03.2
0273:  GOTO   28E
0274:  BCF    03.6
0275:  MOVWF  32
0276:  BSF    03.6
0277:  MOVF   0D,W
0278:  BCF    03.6
0279:  MOVWF  33
027A:  BSF    03.6
027B:  MOVF   0F,W
027C:  BCF    03.6
027D:  MOVWF  34
027E:  MOVF   32,W
027F:  MOVWF  36
0280:  CALL   215
0281:  MOVF   33,W
0282:  BSF    03.6
0283:  MOVWF  0D
0284:  BCF    03.6
0285:  MOVF   34,W
0286:  BSF    03.6
0287:  MOVWF  0F
0288:  INCF   0D,F
0289:  BTFSC  03.2
028A:  INCF   0F,F
028B:  BCF    03.6
028C:  GOTO   24A
028D:  BSF    03.6
028E:  BCF    03.6
028F:  BTFSC  31.7
0290:  BSF    0B.7
0291:  RETURN
0292:  MOVF   0B,W
0293:  MOVWF  32
0294:  BCF    0B.7
0295:  BSF    03.5
0296:  BSF    03.6
0297:  BSF    0C.7
0298:  BSF    0C.0
0299:  NOP
029A:  NOP
029B:  BTFSC  03.0
029C:  GOTO   2C4
029D:  BCF    03.5
029E:  MOVF   0C,W
029F:  ANDLW  7F
02A0:  BCF    03.6
02A1:  MOVWF  33
02A2:  BSF    03.6
02A3:  MOVF   0D,W
02A4:  BCF    03.6
02A5:  MOVWF  34
02A6:  BSF    03.6
02A7:  MOVF   0F,W
02A8:  BCF    03.6
02A9:  MOVWF  35
02AA:  MOVF   33,W
02AB:  MOVWF  36
02AC:  CALL   215
02AD:  MOVF   34,W
02AE:  BSF    03.6
02AF:  MOVWF  0D
02B0:  BCF    03.6
02B1:  MOVF   35,W
02B2:  BSF    03.6
02B3:  MOVWF  0F
02B4:  BSF    03.5
02B5:  BSF    0C.7
02B6:  BSF    0C.0
02B7:  NOP
02B8:  NOP
02B9:  BCF    03.5
02BA:  BCF    03.6
02BB:  DECFSZ 31,F
02BC:  GOTO   2BE
02BD:  GOTO   2C1
02BE:  BSF    03.5
02BF:  BSF    03.6
02C0:  GOTO   2C4
02C1:  GOTO   2E3
02C2:  BSF    03.5
02C3:  BSF    03.6
02C4:  BCF    03.5
02C5:  RLF    0C,W
02C6:  RLF    0E,W
02C7:  ANDLW  7F
02C8:  BCF    03.6
02C9:  MOVWF  33
02CA:  BSF    03.6
02CB:  MOVF   0D,W
02CC:  BCF    03.6
02CD:  MOVWF  34
02CE:  BSF    03.6
02CF:  MOVF   0F,W
02D0:  BCF    03.6
02D1:  MOVWF  35
02D2:  MOVF   33,W
02D3:  MOVWF  36
02D4:  CALL   215
02D5:  MOVF   34,W
02D6:  BSF    03.6
02D7:  MOVWF  0D
02D8:  BCF    03.6
02D9:  MOVF   35,W
02DA:  BSF    03.6
02DB:  MOVWF  0F
02DC:  INCF   0D,F
02DD:  BTFSC  03.2
02DE:  INCF   0F,F
02DF:  BCF    03.0
02E0:  BCF    03.6
02E1:  DECFSZ 31,F
02E2:  GOTO   295
02E3:  BTFSC  32.7
02E4:  BSF    0B.7
02E5:  RETURN
02E6:  MOVF   34,W
02E7:  CLRF   78
02E8:  SUBWF  33,W
02E9:  BTFSC  03.0
02EA:  GOTO   2EE
02EB:  MOVF   33,W
02EC:  MOVWF  77
02ED:  GOTO   2FA
02EE:  CLRF   77
02EF:  MOVLW  08
02F0:  MOVWF  35
02F1:  RLF    33,F
02F2:  RLF    77,F
02F3:  MOVF   34,W
02F4:  SUBWF  77,W
02F5:  BTFSC  03.0
02F6:  MOVWF  77
02F7:  RLF    78,F
02F8:  DECFSZ 35,F
02F9:  GOTO   2F1
02FA:  RETURN
02FB:  MOVF   78,W
02FC:  MOVF   31,W
02FD:  MOVWF  33
02FE:  MOVLW  64
02FF:  MOVWF  34
0300:  CALL   2E6
0301:  MOVF   77,W
0302:  MOVWF  31
0303:  MOVF   78,W
0304:  MOVLW  30
0305:  BTFSS  03.2
0306:  GOTO   30E
0307:  BTFSS  32.1
0308:  GOTO   315
0309:  BTFSC  32.3
030A:  GOTO   315
030B:  BTFSC  32.4
030C:  MOVLW  20
030D:  GOTO   311
030E:  BCF    32.3
030F:  BCF    32.4
0310:  BSF    32.0
0311:  ADDWF  78,F
0312:  MOVF   78,W
0313:  MOVWF  36
0314:  CALL   215
0315:  MOVF   31,W
0316:  MOVWF  33
0317:  MOVLW  0A
0318:  MOVWF  34
0319:  CALL   2E6
031A:  MOVF   77,W
031B:  MOVWF  31
031C:  MOVF   78,W
031D:  MOVLW  30
031E:  BTFSS  03.2
031F:  GOTO   326
0320:  BTFSC  32.3
0321:  GOTO   32A
0322:  BTFSS  32.0
0323:  GOTO   32A
0324:  BTFSC  32.4
0325:  MOVLW  20
0326:  ADDWF  78,F
0327:  MOVF   78,W
0328:  MOVWF  36
0329:  CALL   215
032A:  MOVLW  30
032B:  ADDWF  31,F
032C:  MOVF   31,W
032D:  MOVWF  36
032E:  CALL   215
032F:  RETURN
0330:  MOVLW  8E
0331:  MOVWF  77
0332:  MOVF   34,W
0333:  MOVWF  78
0334:  MOVF   33,W
0335:  MOVWF  79
0336:  CLRF   7A
0337:  MOVF   78,F
0338:  BTFSS  03.2
0339:  GOTO   344
033A:  MOVF   79,W
033B:  MOVWF  78
033C:  CLRF   79
033D:  MOVLW  08
033E:  SUBWF  77,F
033F:  MOVF   78,F
0340:  BTFSS  03.2
0341:  GOTO   344
0342:  CLRF   77
0343:  GOTO   34C
0344:  BCF    03.0
0345:  BTFSC  78.7
0346:  GOTO   34B
0347:  RLF    79,F
0348:  RLF    78,F
0349:  DECF   77,F
034A:  GOTO   344
034B:  BCF    78.7
034C:  RETURN
034D:  MOVF   33,W
034E:  BTFSC  03.2
034F:  GOTO   3BD
0350:  MOVWF  3B
0351:  MOVF   37,W
0352:  BTFSC  03.2
0353:  GOTO   3BD
0354:  ADDWF  3B,F
0355:  BTFSC  03.0
0356:  GOTO   35E
0357:  MOVLW  7F
0358:  SUBWF  3B,F
0359:  BTFSS  03.0
035A:  GOTO   3BD
035B:  BTFSC  03.2
035C:  GOTO   3BD
035D:  GOTO   362
035E:  MOVLW  81
035F:  ADDWF  3B,F
0360:  BTFSC  03.0
0361:  GOTO   3BD
0362:  MOVF   3B,W
0363:  MOVWF  77
0364:  CLRF   78
0365:  CLRF   79
0366:  CLRF   7A
0367:  MOVF   34,W
0368:  MOVWF  3F
0369:  BSF    3F.7
036A:  MOVF   35,W
036B:  MOVWF  3E
036C:  MOVF   36,W
036D:  MOVWF  3D
036E:  MOVLW  18
036F:  MOVWF  3B
0370:  CLRF   3C
0371:  BTFSS  3D.0
0372:  GOTO   38B
0373:  MOVF   3A,W
0374:  ADDWF  7A,F
0375:  BTFSS  03.0
0376:  GOTO   37D
0377:  INCF   79,F
0378:  BTFSS  03.2
0379:  GOTO   37D
037A:  INCF   78,F
037B:  BTFSC  03.2
037C:  BSF    3C.7
037D:  MOVF   39,W
037E:  ADDWF  79,F
037F:  BTFSS  03.0
0380:  GOTO   384
0381:  INCF   78,F
0382:  BTFSC  03.2
0383:  BSF    3C.7
0384:  MOVF   38,W
0385:  MOVWF  35
0386:  BSF    35.7
0387:  MOVF   35,W
0388:  ADDWF  78,F
0389:  BTFSC  03.0
038A:  BSF    3C.7
038B:  RLF    3C,F
038C:  RRF    78,F
038D:  RRF    79,F
038E:  RRF    7A,F
038F:  RRF    3F,F
0390:  RRF    3E,F
0391:  RRF    3D,F
0392:  BCF    03.0
0393:  DECFSZ 3B,F
0394:  GOTO   370
0395:  MOVLW  01
0396:  ADDWF  77,F
0397:  BTFSC  03.0
0398:  GOTO   3BD
0399:  BTFSC  78.7
039A:  GOTO   3A2
039B:  RLF    3F,F
039C:  RLF    7A,F
039D:  RLF    79,F
039E:  RLF    78,F
039F:  DECF   77,F
03A0:  BTFSC  03.2
03A1:  GOTO   3BD
03A2:  BTFSS  3F.7
03A3:  GOTO   3B3
03A4:  INCF   7A,F
03A5:  BTFSS  03.2
03A6:  GOTO   3B3
03A7:  INCF   79,F
03A8:  BTFSS  03.2
03A9:  GOTO   3B3
03AA:  INCF   78,F
03AB:  BTFSS  03.2
03AC:  GOTO   3B3
03AD:  RRF    78,F
03AE:  RRF    79,F
03AF:  RRF    7A,F
03B0:  INCF   77,F
03B1:  BTFSC  03.2
03B2:  GOTO   3BD
03B3:  MOVF   34,W
03B4:  MOVWF  3C
03B5:  MOVF   38,W
03B6:  XORWF  3C,F
03B7:  BTFSS  3C.7
03B8:  GOTO   3BB
03B9:  BSF    78.7
03BA:  GOTO   3C1
03BB:  BCF    78.7
03BC:  GOTO   3C1
03BD:  CLRF   77
03BE:  CLRF   78
03BF:  CLRF   79
03C0:  CLRF   7A
03C1:  RETURN
03C2:  MOVLW  8E
03C3:  MOVWF  77
03C4:  MOVF   33,W
03C5:  SUBWF  77,F
03C6:  MOVF   34,W
03C7:  MOVWF  79
03C8:  MOVF   35,W
03C9:  MOVWF  78
03CA:  BSF    79.7
03CB:  MOVF   77,F
03CC:  BTFSC  03.2
03CD:  GOTO   3D9
03CE:  BCF    03.0
03CF:  MOVF   79,F
03D0:  BTFSS  03.2
03D1:  GOTO   3D5
03D2:  MOVF   78,F
03D3:  BTFSC  03.2
03D4:  GOTO   3D9
03D5:  RRF    79,F
03D6:  RRF    78,F
03D7:  DECFSZ 77,F
03D8:  GOTO   3CE
03D9:  BTFSS  34.7
03DA:  GOTO   3E0
03DB:  COMF   78,F
03DC:  COMF   79,F
03DD:  INCF   78,F
03DE:  BTFSC  03.2
03DF:  INCF   79,F
03E0:  RETURN
*
07E1:  BSF    0A.0
07E2:  BSF    0A.1
07E3:  BSF    0A.2
07E4:  ADDWF  02,F
07E5:  GOTO   4AF
07E6:  GOTO   4B5
07E7:  GOTO   4EF
07E8:  GOTO   589
07E9:  GOTO   5D5
07EA:  GOTO   694
07EB:  GOTO   75F
....................  
.................... #list 
....................  
.................... #device ADC=8 
....................  
.................... #FUSES XT                       //Crystal osc <= 4mhz 
.................... #FUSES NOPUT                    //No Power Up Timer 
.................... #FUSES NOPROTECT                //Code not protected from reading 
.................... #FUSES NODEBUG                  //No Debug mode for ICD 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOCPD                    //No EE protection 
.................... #FUSES NOWRT                    //Program memory not write protected 
....................  
.................... #use delay(crystal=4000000) 
*
0132:  MOVLW  37
0133:  MOVWF  04
0134:  BCF    03.7
0135:  MOVF   00,W
0136:  BTFSC  03.2
0137:  GOTO   146
0138:  MOVLW  01
0139:  MOVWF  78
013A:  CLRF   77
013B:  DECFSZ 77,F
013C:  GOTO   13B
013D:  DECFSZ 78,F
013E:  GOTO   13A
013F:  MOVLW  4A
0140:  MOVWF  77
0141:  DECFSZ 77,F
0142:  GOTO   141
0143:  GOTO   144
0144:  DECFSZ 00,F
0145:  GOTO   138
0146:  RETURN
....................  
....................  
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
015F:  MOVLW  0F
0160:  BSF    03.5
0161:  ANDWF  08,W
0162:  IORLW  F0
0163:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0164:  BCF    03.5
0165:  BSF    08.2
....................    delay_cycles(1); 
0166:  NOP
....................    lcd_output_enable(1); 
0167:  BSF    08.0
....................    delay_cycles(1); 
0168:  NOP
....................    high = lcd_read_nibble(); 
0169:  CALL   153
016A:  MOVF   78,W
016B:  MOVWF  3E
....................        
....................    lcd_output_enable(0); 
016C:  BCF    08.0
....................    delay_cycles(1); 
016D:  NOP
....................    lcd_output_enable(1); 
016E:  BSF    08.0
....................    delay_us(1); 
016F:  NOP
....................    low = lcd_read_nibble(); 
0170:  CALL   153
0171:  MOVF   78,W
0172:  MOVWF  3D
....................        
....................    lcd_output_enable(0); 
0173:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0174:  MOVLW  0F
0175:  BSF    03.5
0176:  ANDWF  08,W
0177:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0178:  BCF    03.5
0179:  SWAPF  3E,W
017A:  MOVWF  77
017B:  MOVLW  F0
017C:  ANDWF  77,F
017D:  MOVF   77,W
017E:  IORWF  3D,W
017F:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
0153:  MOVF   08,W
0154:  MOVWF  77
0155:  SWAPF  08,W
0156:  ANDLW  0F
0157:  MOVWF  78
....................   #endif 
0158:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
0147:  SWAPF  3E,W
0148:  ANDLW  F0
0149:  MOVWF  77
014A:  MOVLW  0F
014B:  ANDWF  08,W
014C:  IORWF  77,W
014D:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
014E:  NOP
....................    lcd_output_enable(1); 
014F:  BSF    08.0
....................    delay_us(2); 
0150:  GOTO   151
....................    lcd_output_enable(0); 
0151:  BCF    08.0
0152:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0159:  BSF    03.5
015A:  BCF    08.0
....................    lcd_rs_tris(); 
015B:  BCF    08.1
....................    lcd_rw_tris(); 
015C:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
015D:  BCF    03.5
015E:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0180:  MOVF   78,W
0181:  MOVWF  3D
0182:  BTFSC  3D.7
0183:  GOTO   15F
....................    lcd_output_rs(address); 
0184:  BTFSS  3B.0
0185:  BCF    08.1
0186:  BTFSC  3B.0
0187:  BSF    08.1
....................    delay_cycles(1); 
0188:  NOP
....................    lcd_output_rw(0); 
0189:  BCF    08.2
....................    delay_cycles(1); 
018A:  NOP
....................    lcd_output_enable(0); 
018B:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
018C:  SWAPF  3C,W
018D:  MOVWF  3D
018E:  MOVLW  0F
018F:  ANDWF  3D,F
0190:  MOVF   3D,W
0191:  MOVWF  3E
0192:  CALL   147
....................    lcd_send_nibble(n & 0xf); 
0193:  MOVF   3C,W
0194:  ANDLW  0F
0195:  MOVWF  3D
0196:  MOVWF  3E
0197:  CALL   147
0198:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0199:  MOVLW  0F
019A:  BSF    03.5
019B:  ANDWF  08,W
019C:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
019D:  BCF    08.0
....................    lcd_rs_tris(); 
019E:  BCF    08.1
....................    lcd_rw_tris(); 
019F:  BCF    08.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
01A0:  BCF    03.5
01A1:  BCF    08.1
....................    lcd_output_rw(0); 
01A2:  BCF    08.2
....................    lcd_output_enable(0); 
01A3:  BCF    08.0
....................      
....................    delay_ms(15); 
01A4:  MOVLW  0F
01A5:  MOVWF  37
01A6:  CALL   132
....................    for(i=1;i<=3;++i) 
01A7:  MOVLW  01
01A8:  MOVWF  31
01A9:  MOVF   31,W
01AA:  SUBLW  03
01AB:  BTFSS  03.0
01AC:  GOTO   1B5
....................    { 
....................        lcd_send_nibble(3); 
01AD:  MOVLW  03
01AE:  MOVWF  3E
01AF:  CALL   147
....................        delay_ms(5); 
01B0:  MOVLW  05
01B1:  MOVWF  37
01B2:  CALL   132
01B3:  INCF   31,F
01B4:  GOTO   1A9
....................    } 
....................     
....................    lcd_send_nibble(2); 
01B5:  MOVLW  02
01B6:  MOVWF  3E
01B7:  CALL   147
....................    delay_ms(5); 
01B8:  MOVLW  05
01B9:  MOVWF  37
01BA:  CALL   132
....................    for(i=0;i<=3;++i) 
01BB:  CLRF   31
01BC:  MOVF   31,W
01BD:  SUBLW  03
01BE:  BTFSS  03.0
01BF:  GOTO   1C9
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
01C0:  MOVF   31,W
01C1:  CALL   031
01C2:  MOVWF  32
01C3:  CLRF   3B
01C4:  MOVF   32,W
01C5:  MOVWF  3C
01C6:  CALL   159
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01C7:  INCF   31,F
01C8:  GOTO   1BC
01C9:  BCF    0A.3
01CA:  BCF    0A.4
01CB:  GOTO   4A9 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0203:  DECFSZ 38,W
0204:  GOTO   206
0205:  GOTO   209
....................       address=LCD_LINE_TWO; 
0206:  MOVLW  40
0207:  MOVWF  39
0208:  GOTO   20A
....................    else 
....................       address=0; 
0209:  CLRF   39
....................       
....................    address+=x-1; 
020A:  MOVLW  01
020B:  SUBWF  37,W
020C:  ADDWF  39,F
....................    lcd_send_byte(0,0x80|address); 
020D:  MOVF   39,W
020E:  IORLW  80
020F:  MOVWF  3A
0210:  CLRF   3B
0211:  MOVF   3A,W
0212:  MOVWF  3C
0213:  CALL   159
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0214:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0215:  MOVF   36,W
0216:  XORLW  07
0217:  BTFSC  03.2
0218:  GOTO   223
0219:  XORLW  0B
021A:  BTFSC  03.2
021B:  GOTO   228
021C:  XORLW  06
021D:  BTFSC  03.2
021E:  GOTO   230
021F:  XORLW  02
0220:  BTFSC  03.2
0221:  GOTO   236
0222:  GOTO   23B
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0223:  MOVLW  01
0224:  MOVWF  37
0225:  MOVWF  38
0226:  CALL   203
0227:  GOTO   240
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0228:  CLRF   3B
0229:  MOVLW  01
022A:  MOVWF  3C
022B:  CALL   159
....................                      delay_ms(2); 
022C:  MOVLW  02
022D:  MOVWF  37
022E:  CALL   132
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
022F:  GOTO   240
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0230:  MOVLW  01
0231:  MOVWF  37
0232:  MOVLW  02
0233:  MOVWF  38
0234:  CALL   203
0235:  GOTO   240
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0236:  CLRF   3B
0237:  MOVLW  10
0238:  MOVWF  3C
0239:  CALL   159
023A:  GOTO   240
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
023B:  MOVLW  01
023C:  MOVWF  3B
023D:  MOVF   36,W
023E:  MOVWF  3C
023F:  CALL   159
....................      #endif 
....................    } 
0240:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0484:  BCF    03.5
0485:  CLRF   27
0486:  CLRF   28
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //Quando o sensor  digital 0  ativo e 1  inativo 
....................  
.................... //variaveis de entrada  
.................... //DIGITAL 
.................... #define i_SENSOR_NIVEL          pin_b2 //sensor nivel da agua  
....................  
....................  
.................... //variaveis de saida 
.................... #define o_VALVULA_CL           pin_c0 //valvula do cloro 
.................... #define o_LED_PH               pin_c1 //LED da ALCALINIDADE 
.................... #define o_VALVULA_AGUA         pin_c2 //valvula de agua 
.................... #define o_FILTRA               pin_c3 //Motor do filtro 
.................... #define o_LED_FILTRA           pin_c4 //LED do filtro 
.................... #define o_ALGICIDA             pin_c5 //Motor do algicida 
.................... #define o_LED_ALGICIDA         pin_c6 //LED do algicida 
.................... #define o_LED_AT               pin_c7 //LED da ALCALINIDADE 
.................... #define o_LED_CL               pin_d3 //LED do CLORO 
....................  
....................  
....................  
....................  
....................  
.................... // One of the following may be OR'ed in with the above:  
....................  
.................... #define WDT_ON             0x4100          
.................... #define WDT_DIV_16         0x100  
.................... #define WDT_DIV_8          0x300  
.................... #define WDT_DIV_4          0x500  
.................... #define WDT_DIV_2          0x700  
.................... #define WDT_TIMES_1        0x900  // Default  
.................... #define WDT_TIMES_2        0xB00  
.................... #define WDT_TIMES_4        0xD00  
.................... #define WDT_TIMES_8        0xF00  
.................... #define WDT_TIMES_16      0x1100  
.................... #define WDT_TIMES_32      0x1300  
.................... #define WDT_TIMES_64      0x1500  
.................... #define WDT_TIMES_128     0x1700 
....................  
....................  
.................... //int1 flag=0; //Flag de interrupo 
.................... byte i=0; //Varivel contadora do timer1 
.................... byte estado=0; //Varivel indicativa da mquina de estados 
.................... char c; //Varivel de escrita de caractere no LCD 
.................... int at=0, ph=0, cl=0, cont=0; //Entradas Analgicas 
....................  
....................  
....................  
....................  
.................... //Leitura da porta RA0 - Sensor de Alcalinidade total 
.................... int le_A0(){   
....................    restart_wdt();   
*
03E1:  CLRWDT
....................    int analogico, at; 
....................    set_adc_channel(0); 
03E2:  MOVLW  00
03E3:  MOVWF  78
03E4:  MOVF   1F,W
03E5:  ANDLW  C7
03E6:  IORWF  78,W
03E7:  MOVWF  1F
....................    delay_ms(1); 
03E8:  MOVLW  01
03E9:  MOVWF  37
03EA:  CALL   132
....................    analogico = read_adc(); 
03EB:  BSF    1F.2
03EC:  BTFSC  1F.2
03ED:  GOTO   3EC
03EE:  MOVF   1E,W
03EF:  MOVWF  31
....................    at = (analogico * 0.0390625); 
03F0:  CLRF   34
03F1:  MOVF   31,W
03F2:  MOVWF  33
03F3:  CALL   330
03F4:  MOVF   7A,W
03F5:  MOVWF  36
03F6:  MOVF   79,W
03F7:  MOVWF  35
03F8:  MOVF   78,W
03F9:  MOVWF  34
03FA:  MOVF   77,W
03FB:  MOVWF  33
03FC:  CLRF   3A
03FD:  CLRF   39
03FE:  MOVLW  20
03FF:  MOVWF  38
0400:  MOVLW  7A
0401:  MOVWF  37
0402:  CALL   34D
0403:  MOVF   7A,W
0404:  MOVWF  36
0405:  MOVF   79,W
0406:  MOVWF  35
0407:  MOVF   78,W
0408:  MOVWF  34
0409:  MOVF   77,W
040A:  MOVWF  33
040B:  CALL   3C2
040C:  MOVF   78,W
040D:  MOVWF  32
....................    return at; 
040E:  MOVF   32,W
040F:  MOVWF  78
0410:  RETURN
.................... } 
....................  
....................  
....................  
.................... //Leitura da porta RA1 - Sensor de PH 
....................    int le_A1(){   
....................    restart_wdt();   
0411:  CLRWDT
....................    int analogico, ph; 
....................    set_adc_channel(1); 
0412:  MOVLW  08
0413:  MOVWF  78
0414:  MOVF   1F,W
0415:  ANDLW  C7
0416:  IORWF  78,W
0417:  MOVWF  1F
....................    delay_ms(1); 
0418:  MOVLW  01
0419:  MOVWF  37
041A:  CALL   132
....................    analogico = read_adc(); 
041B:  BSF    1F.2
041C:  BTFSC  1F.2
041D:  GOTO   41C
041E:  MOVF   1E,W
041F:  MOVWF  31
....................    ph = (analogico * 0.0390625); 
0420:  CLRF   34
0421:  MOVF   31,W
0422:  MOVWF  33
0423:  CALL   330
0424:  MOVF   7A,W
0425:  MOVWF  36
0426:  MOVF   79,W
0427:  MOVWF  35
0428:  MOVF   78,W
0429:  MOVWF  34
042A:  MOVF   77,W
042B:  MOVWF  33
042C:  CLRF   3A
042D:  CLRF   39
042E:  MOVLW  20
042F:  MOVWF  38
0430:  MOVLW  7A
0431:  MOVWF  37
0432:  CALL   34D
0433:  MOVF   7A,W
0434:  MOVWF  36
0435:  MOVF   79,W
0436:  MOVWF  35
0437:  MOVF   78,W
0438:  MOVWF  34
0439:  MOVF   77,W
043A:  MOVWF  33
043B:  CALL   3C2
043C:  MOVF   78,W
043D:  MOVWF  32
....................    return ph; 
043E:  MOVF   32,W
043F:  MOVWF  78
0440:  RETURN
.................... } 
....................  
....................  
....................  
.................... //Leitura da porta RA2 - Sensor de cloro 
.................... int le_A2(){   
....................    restart_wdt();    
0441:  CLRWDT
....................    int analogico, cl; 
....................    set_adc_channel(2); 
0442:  MOVLW  10
0443:  MOVWF  78
0444:  MOVF   1F,W
0445:  ANDLW  C7
0446:  IORWF  78,W
0447:  MOVWF  1F
....................    delay_ms(1); 
0448:  MOVLW  01
0449:  MOVWF  37
044A:  CALL   132
....................    analogico = read_adc(); 
044B:  BSF    1F.2
044C:  BTFSC  1F.2
044D:  GOTO   44C
044E:  MOVF   1E,W
044F:  MOVWF  31
....................    cl = (analogico * 0.0390625); 
0450:  CLRF   34
0451:  MOVF   31,W
0452:  MOVWF  33
0453:  CALL   330
0454:  MOVF   7A,W
0455:  MOVWF  36
0456:  MOVF   79,W
0457:  MOVWF  35
0458:  MOVF   78,W
0459:  MOVWF  34
045A:  MOVF   77,W
045B:  MOVWF  33
045C:  CLRF   3A
045D:  CLRF   39
045E:  MOVLW  20
045F:  MOVWF  38
0460:  MOVLW  7A
0461:  MOVWF  37
0462:  CALL   34D
0463:  MOVF   7A,W
0464:  MOVWF  36
0465:  MOVF   79,W
0466:  MOVWF  35
0467:  MOVF   78,W
0468:  MOVWF  34
0469:  MOVF   77,W
046A:  MOVWF  33
046B:  CALL   3C2
046C:  MOVF   78,W
046D:  MOVWF  32
....................    return cl; 
046E:  MOVF   32,W
046F:  MOVWF  78
0470:  RETURN
.................... } 
....................  
....................  
.................... //limpa o LCD 
.................... void limpar(){ 
....................    c='\f'; 
*
0241:  MOVLW  0C
0242:  MOVWF  2B
....................    lcd_putc(c); 
0243:  MOVF   2B,W
0244:  MOVWF  36
0245:  CALL   215
0246:  RETURN
.................... } 
....................    
....................    
.................... void inicializar(){ 
....................    output_low(o_VALVULA_AGUA); 
*
01CC:  BCF    30.2
01CD:  MOVF   30,W
01CE:  BSF    03.5
01CF:  MOVWF  07
01D0:  BCF    03.5
01D1:  BCF    07.2
....................    output_low(o_FILTRA); 
01D2:  BCF    30.3
01D3:  MOVF   30,W
01D4:  BSF    03.5
01D5:  MOVWF  07
01D6:  BCF    03.5
01D7:  BCF    07.3
....................    output_low(o_LED_FILTRA); 
01D8:  BCF    30.4
01D9:  MOVF   30,W
01DA:  BSF    03.5
01DB:  MOVWF  07
01DC:  BCF    03.5
01DD:  BCF    07.4
....................    output_low(o_ALGICIDA); 
01DE:  BCF    30.5
01DF:  MOVF   30,W
01E0:  BSF    03.5
01E1:  MOVWF  07
01E2:  BCF    03.5
01E3:  BCF    07.5
....................    output_low(o_LED_ALGICIDA); 
01E4:  BCF    30.6
01E5:  MOVF   30,W
01E6:  BSF    03.5
01E7:  MOVWF  07
01E8:  BCF    03.5
01E9:  BCF    07.6
....................    output_low(o_LED_AT); 
01EA:  BCF    30.7
01EB:  MOVF   30,W
01EC:  BSF    03.5
01ED:  MOVWF  07
01EE:  BCF    03.5
01EF:  BCF    07.7
....................    output_low(o_LED_PH); 
01F0:  BCF    30.1
01F1:  MOVF   30,W
01F2:  BSF    03.5
01F3:  MOVWF  07
01F4:  BCF    03.5
01F5:  BCF    07.1
....................    output_low(o_VALVULA_CL); 
01F6:  BCF    30.0
01F7:  MOVF   30,W
01F8:  BSF    03.5
01F9:  MOVWF  07
01FA:  BCF    03.5
01FB:  BCF    07.0
....................    output_low(o_LED_CL); 
01FC:  BSF    03.5
01FD:  BCF    08.3
01FE:  BCF    03.5
01FF:  BCF    08.3
0200:  BCF    0A.3
0201:  BCF    0A.4
0202:  GOTO   4B1 (RETURN)
.................... }   
....................    
....................    
....................    
.................... #int_timer1 
.................... void timer1_isr(){ 
....................    //S ira incrementar se no 1 
....................    if(estado==2||estado==3){ 
*
0039:  MOVF   2A,W
003A:  SUBLW  02
003B:  BTFSC  03.2
003C:  GOTO   041
003D:  MOVF   2A,W
003E:  SUBLW  03
003F:  BTFSS  03.2
0040:  GOTO   048
....................       clear_interrupt(INT_TIMER1); 
0041:  BCF    0C.0
....................       set_timer1(3036); 
0042:  CLRF   0E
0043:  MOVLW  0B
0044:  MOVWF  0F
0045:  MOVLW  DC
0046:  MOVWF  0E
....................       i++; 
0047:  INCF   29,F
....................    } 
0048:  BCF    0C.0
0049:  BCF    0A.3
004A:  BCF    0A.4
004B:  GOTO   01D
.................... }   
....................    
....................  
....................  
.................... void main(){ 
*
0471:  MOVF   03,W
0472:  ANDLW  1F
0473:  MOVWF  03
0474:  CLRF   29
0475:  CLRF   2A
0476:  CLRF   2C
0477:  CLRF   2D
0478:  CLRF   2E
0479:  CLRF   2F
047A:  MOVLW  FF
047B:  MOVWF  30
047C:  BSF    03.5
047D:  BSF    1F.0
047E:  BSF    1F.1
047F:  BSF    1F.2
0480:  BCF    1F.3
0481:  MOVLW  07
0482:  MOVWF  1C
0483:  BCF    03.7
....................  
....................  
....................    //Configuraes       
....................    setup_adc_ports(AN0_AN1_AN3); 
*
0487:  BSF    03.5
0488:  BCF    1F.0
0489:  BCF    1F.1
048A:  BSF    1F.2
048B:  BCF    1F.3
....................    setup_adc(ADC_CLOCK_INTERNAL); 
048C:  BCF    1F.6
048D:  BCF    03.5
048E:  BSF    1F.6
048F:  BSF    1F.7
0490:  BSF    03.5
0491:  BCF    1F.7
0492:  BCF    03.5
0493:  BSF    1F.0
....................    Port_b_pullups(true); 
0494:  BSF    03.5
0495:  BCF    01.7
....................    enable_interrupts(global); 
0496:  MOVLW  C0
0497:  BCF    03.5
0498:  IORWF  0B,F
....................    enable_interrupts(int_ext); 
0499:  BSF    0B.4
....................    enable_interrupts(INT_TIMER1); 
049A:  BSF    03.5
049B:  BSF    0C.0
....................    clear_interrupt(INT_TIMER1); 
049C:  BCF    03.5
049D:  BCF    0C.0
....................    setup_timer_1 ( T1_INTERNAL | T1_DIV_BY_8 ); 
049E:  MOVLW  B5
049F:  MOVWF  10
....................    set_timer1(3036); 
04A0:  CLRF   0E
04A1:  MOVLW  0B
04A2:  MOVWF  0F
04A3:  MOVLW  DC
04A4:  MOVWF  0E
....................    ext_int_edge(H_to_L); 
04A5:  BSF    03.5
04A6:  BCF    01.6
....................    lcd_init(); 
04A7:  BCF    03.5
04A8:  GOTO   199
....................  
....................    while(TRUE){ 
....................      
....................     switch(estado){ 
04A9:  MOVF   2A,W
04AA:  ADDLW  F9
04AB:  BTFSC  03.0
04AC:  GOTO   7DF
04AD:  ADDLW  07
04AE:  GOTO   7E1
....................             //Estado 0 - Inicializao 
....................             case 0: 
....................                 
....................                i=0; 
04AF:  CLRF   29
....................                inicializar(); 
04B0:  GOTO   1CC
....................                limpar(); 
04B1:  CALL   241
....................                estado=1; 
04B2:  MOVLW  01
04B3:  MOVWF  2A
....................             break; 
04B4:  GOTO   7DF
....................              
....................             //Estado 1 - Enchimento da piscina  
....................             case 1: 
....................                   
....................                  while((input(i_SENSOR_NIVEL)==1)&&(estado==1)){ 
04B5:  BSF    03.5
04B6:  BSF    06.2
04B7:  BCF    03.5
04B8:  BTFSS  06.2
04B9:  GOTO   4D7
04BA:  DECFSZ 2A,W
04BB:  GOTO   4D7
....................                   printf(LCD_PUTC, "Enchendo      \n"); 
04BC:  MOVLW  4C
04BD:  BSF    03.6
04BE:  MOVWF  0D
04BF:  MOVLW  00
04C0:  MOVWF  0F
04C1:  BCF    03.6
04C2:  CALL   247
....................                    
....................                   delay_ms(150); 
04C3:  MOVLW  96
04C4:  MOVWF  37
04C5:  CALL   132
....................                   output_high(o_VALVULA_AGUA); 
04C6:  BCF    30.2
04C7:  MOVF   30,W
04C8:  BSF    03.5
04C9:  MOVWF  07
04CA:  BCF    03.5
04CB:  BSF    07.2
....................                   delay_ms(150); 
04CC:  MOVLW  96
04CD:  MOVWF  37
04CE:  CALL   132
....................                   output_low(o_VALVULA_AGUA); 
04CF:  BCF    30.2
04D0:  MOVF   30,W
04D1:  BSF    03.5
04D2:  MOVWF  07
04D3:  BCF    03.5
04D4:  BCF    07.2
....................                   limpar(); 
04D5:  CALL   241
04D6:  GOTO   4B5
....................                  } 
....................                  limpar(); 
04D7:  CALL   241
....................                  output_high(o_VALVULA_AGUA); 
04D8:  BCF    30.2
04D9:  MOVF   30,W
04DA:  BSF    03.5
04DB:  MOVWF  07
04DC:  BCF    03.5
04DD:  BSF    07.2
....................                  printf(LCD_PUTC, "1:OK      \n"); 
04DE:  MOVLW  54
04DF:  BSF    03.6
04E0:  MOVWF  0D
04E1:  MOVLW  00
04E2:  MOVWF  0F
04E3:  BCF    03.6
04E4:  CALL   247
....................                  delay_ms(500); 
04E5:  MOVLW  02
04E6:  MOVWF  31
04E7:  MOVLW  FA
04E8:  MOVWF  37
04E9:  CALL   132
04EA:  DECFSZ 31,F
04EB:  GOTO   4E7
....................                  estado=2; 
04EC:  MOVLW  02
04ED:  MOVWF  2A
....................             break; 
04EE:  GOTO   7DF
....................              
....................             //Estado 2 - Filtrar piscina.. liga o motor por x tempo, depois desse x tempo ele desliga o motor e mostra 2:OK 
....................             case 2: 
....................                   limpar(); 
04EF:  CALL   241
....................                    
....................                    
....................                   if(cont!=0){//SE NAO FOR A PRIMEIRA VEZ... 
04F0:  MOVF   2F,F
04F1:  BTFSC  03.2
04F2:  GOTO   53E
....................                       cont=0; 
04F3:  CLRF   2F
....................                       i=0; 
04F4:  CLRF   29
....................                        
....................                       while((i<7)){ //alguns segundos 
04F5:  MOVF   29,W
04F6:  SUBLW  06
04F7:  BTFSS  03.0
04F8:  GOTO   521
....................                         printf(LCD_PUTC, "Filtrando   %u   \n",i); 
04F9:  MOVLW  5A
04FA:  BSF    03.6
04FB:  MOVWF  0D
04FC:  MOVLW  00
04FD:  MOVWF  0F
04FE:  BCF    03.0
04FF:  MOVLW  0C
0500:  BCF    03.6
0501:  MOVWF  31
0502:  CALL   292
0503:  MOVF   29,W
0504:  MOVWF  31
0505:  MOVLW  1B
0506:  MOVWF  32
0507:  CALL   2FB
0508:  MOVLW  61
0509:  BSF    03.6
050A:  MOVWF  0D
050B:  MOVLW  00
050C:  MOVWF  0F
050D:  BCF    03.0
050E:  MOVLW  04
050F:  BCF    03.6
0510:  MOVWF  31
0511:  CALL   292
....................                         output_high(o_FILTRA); 
0512:  BCF    30.3
0513:  MOVF   30,W
0514:  BSF    03.5
0515:  MOVWF  07
0516:  BCF    03.5
0517:  BSF    07.3
....................                         delay_ms(450); 
0518:  MOVLW  02
0519:  MOVWF  31
051A:  MOVLW  E1
051B:  MOVWF  37
051C:  CALL   132
051D:  DECFSZ 31,F
051E:  GOTO   51A
....................                         limpar(); 
051F:  CALL   241
0520:  GOTO   4F5
....................                      } 
....................                       
....................                      limpar(); 
0521:  CALL   241
....................                      output_low(o_FILTRA); 
0522:  BCF    30.3
0523:  MOVF   30,W
0524:  BSF    03.5
0525:  MOVWF  07
0526:  BCF    03.5
0527:  BCF    07.3
....................                      output_high(o_LED_FILTRA); //liga quando termina de filtrar para dizer que a etapa esta concluida 
0528:  BCF    30.4
0529:  MOVF   30,W
052A:  BSF    03.5
052B:  MOVWF  07
052C:  BCF    03.5
052D:  BSF    07.4
....................                      printf(LCD_PUTC, "==FIM==     \nAMANHA TEM MAIS"); 
052E:  MOVLW  64
052F:  BSF    03.6
0530:  MOVWF  0D
0531:  MOVLW  00
0532:  MOVWF  0F
0533:  BCF    03.6
0534:  CALL   247
....................                      delay_ms(500); 
0535:  MOVLW  02
0536:  MOVWF  31
0537:  MOVLW  FA
0538:  MOVWF  37
0539:  CALL   132
053A:  DECFSZ 31,F
053B:  GOTO   537
....................                      estado=0; 
053C:  CLRF   2A
....................                      break; 
053D:  GOTO   7DF
....................                   } 
....................                   i=0; 
053E:  CLRF   29
....................                   while((i<3)){ //alguns segundos 
053F:  MOVF   29,W
0540:  SUBLW  02
0541:  BTFSS  03.0
0542:  GOTO   56B
....................                      printf(LCD_PUTC, "Filtrando  %u   \n",i); 
0543:  MOVLW  73
0544:  BSF    03.6
0545:  MOVWF  0D
0546:  MOVLW  00
0547:  MOVWF  0F
0548:  BCF    03.0
0549:  MOVLW  0B
054A:  BCF    03.6
054B:  MOVWF  31
054C:  CALL   292
054D:  MOVF   29,W
054E:  MOVWF  31
054F:  MOVLW  1B
0550:  MOVWF  32
0551:  CALL   2FB
0552:  MOVLW  79
0553:  BSF    03.6
0554:  MOVWF  0D
0555:  MOVLW  00
0556:  MOVWF  0F
0557:  BSF    03.0
0558:  MOVLW  04
0559:  BCF    03.6
055A:  MOVWF  31
055B:  CALL   292
....................                      output_high(o_FILTRA); 
055C:  BCF    30.3
055D:  MOVF   30,W
055E:  BSF    03.5
055F:  MOVWF  07
0560:  BCF    03.5
0561:  BSF    07.3
....................                      delay_ms(450); 
0562:  MOVLW  02
0563:  MOVWF  31
0564:  MOVLW  E1
0565:  MOVWF  37
0566:  CALL   132
0567:  DECFSZ 31,F
0568:  GOTO   564
....................                      limpar(); 
0569:  CALL   241
056A:  GOTO   53F
....................                   } 
....................                   limpar(); 
056B:  CALL   241
....................                   output_low(o_FILTRA); 
056C:  BCF    30.3
056D:  MOVF   30,W
056E:  BSF    03.5
056F:  MOVWF  07
0570:  BCF    03.5
0571:  BCF    07.3
....................                   output_high(o_LED_FILTRA); //liga quando termina de filtrar para dizer que a etapa esta concluida 
0572:  BCF    30.4
0573:  MOVF   30,W
0574:  BSF    03.5
0575:  MOVWF  07
0576:  BCF    03.5
0577:  BSF    07.4
....................                   printf(LCD_PUTC, "1:OK, 2:OK     \n"); 
0578:  MOVLW  7C
0579:  BSF    03.6
057A:  MOVWF  0D
057B:  MOVLW  00
057C:  MOVWF  0F
057D:  BCF    03.6
057E:  CALL   247
....................                   delay_ms(500); 
057F:  MOVLW  02
0580:  MOVWF  31
0581:  MOVLW  FA
0582:  MOVWF  37
0583:  CALL   132
0584:  DECFSZ 31,F
0585:  GOTO   581
....................                   estado=3; 
0586:  MOVLW  03
0587:  MOVWF  2A
....................             break; 
0588:  GOTO   7DF
....................              
....................             /*Estado 3: Aplicar o algicida  
....................             Para evitar o esverdeamento, aplique algicida de manuteno. A dosagem  6 ml por m. 
....................             Use a qualquer horrio do mesmo dia ou da noite que usar o cloro, ou qualquer outro produto. Filtre por 1 horas 
....................             */ 
....................             case 3: 
....................                   limpar(); 
0589:  CALL   241
....................                   i=0; 
058A:  CLRF   29
....................                   while(i<3){ 
058B:  MOVF   29,W
058C:  SUBLW  02
058D:  BTFSS  03.0
058E:  GOTO   5B7
....................                      printf(LCD_PUTC, "Aplic Algicida  %u   \n",i); 
058F:  MOVLW  85
0590:  BSF    03.6
0591:  MOVWF  0D
0592:  MOVLW  00
0593:  MOVWF  0F
0594:  BCF    03.0
0595:  MOVLW  10
0596:  BCF    03.6
0597:  MOVWF  31
0598:  CALL   292
0599:  MOVF   29,W
059A:  MOVWF  31
059B:  MOVLW  1B
059C:  MOVWF  32
059D:  CALL   2FB
059E:  MOVLW  8E
059F:  BSF    03.6
05A0:  MOVWF  0D
05A1:  MOVLW  00
05A2:  MOVWF  0F
05A3:  BCF    03.0
05A4:  MOVLW  04
05A5:  BCF    03.6
05A6:  MOVWF  31
05A7:  CALL   292
....................                      output_high(o_ALGICIDA); 
05A8:  BCF    30.5
05A9:  MOVF   30,W
05AA:  BSF    03.5
05AB:  MOVWF  07
05AC:  BCF    03.5
05AD:  BSF    07.5
....................                      delay_ms(450); 
05AE:  MOVLW  02
05AF:  MOVWF  31
05B0:  MOVLW  E1
05B1:  MOVWF  37
05B2:  CALL   132
05B3:  DECFSZ 31,F
05B4:  GOTO   5B0
....................                      limpar(); 
05B5:  CALL   241
05B6:  GOTO   58B
....................                   } 
....................                   limpar(); 
05B7:  CALL   241
....................                   output_low(o_ALGICIDA); 
05B8:  BCF    30.5
05B9:  MOVF   30,W
05BA:  BSF    03.5
05BB:  MOVWF  07
05BC:  BCF    03.5
05BD:  BCF    07.5
....................                   output_high(o_LED_ALGICIDA);//liga o led pra dizer que a etapa esta concluida 
05BE:  BCF    30.6
05BF:  MOVF   30,W
05C0:  BSF    03.5
05C1:  MOVWF  07
05C2:  BCF    03.5
05C3:  BSF    07.6
....................                   printf(LCD_PUTC, "1:OK, 2:OK, 3:OK    \n"); 
05C4:  MOVLW  91
05C5:  BSF    03.6
05C6:  MOVWF  0D
05C7:  MOVLW  00
05C8:  MOVWF  0F
05C9:  BCF    03.6
05CA:  CALL   247
....................                   delay_ms(500); 
05CB:  MOVLW  02
05CC:  MOVWF  31
05CD:  MOVLW  FA
05CE:  MOVWF  37
05CF:  CALL   132
05D0:  DECFSZ 31,F
05D1:  GOTO   5CD
....................                    
....................                   estado=4; 
05D2:  MOVLW  04
05D3:  MOVWF  2A
....................             break; 
05D4:  GOTO   7DF
....................             
....................             
....................            /*Estado 4: Verifica alcalinidade, se for baixa aplica elevador de alcalinidade,  
....................            se for alta aplica redutor de alcalinidade, se estiver ok vai para proximo estado*/ 
....................            case 4: 
....................                limpar(); 
05D5:  CALL   241
....................                printf(LCD_PUTC, "LENDO SENSOR AT  \n");  
05D6:  MOVLW  9C
05D7:  BSF    03.6
05D8:  MOVWF  0D
05D9:  MOVLW  00
05DA:  MOVWF  0F
05DB:  BCF    03.6
05DC:  CALL   247
....................                delay_ms(500); 
05DD:  MOVLW  02
05DE:  MOVWF  31
05DF:  MOVLW  FA
05E0:  MOVWF  37
05E1:  CALL   132
05E2:  DECFSZ 31,F
05E3:  GOTO   5DF
....................                at = le_A0(); 
05E4:  CALL   3E1
05E5:  MOVF   78,W
05E6:  MOVWF  2C
....................                
....................                 
....................                while((at!=7)||(at!=8)){ 
05E7:  MOVF   2C,W
05E8:  SUBLW  07
05E9:  BTFSS  03.2
05EA:  GOTO   5EF
05EB:  MOVF   2C,W
05EC:  SUBLW  08
05ED:  BTFSC  03.2
05EE:  GOTO   692
....................                 
....................                    if((at==7)||(at==8)){  // alcalinidade ideal 
05EF:  MOVF   2C,W
05F0:  SUBLW  07
05F1:  BTFSC  03.2
05F2:  GOTO   5F7
05F3:  MOVF   2C,W
05F4:  SUBLW  08
05F5:  BTFSS  03.2
05F6:  GOTO   631
....................                       limpar(); 
05F7:  CALL   241
....................                       printf(LCD_PUTC, "AT IDEAL:  %u   \n",at); 
05F8:  MOVLW  A6
05F9:  BSF    03.6
05FA:  MOVWF  0D
05FB:  MOVLW  00
05FC:  MOVWF  0F
05FD:  BCF    03.0
05FE:  MOVLW  0B
05FF:  BCF    03.6
0600:  MOVWF  31
0601:  CALL   292
0602:  MOVF   2C,W
0603:  MOVWF  31
0604:  MOVLW  1B
0605:  MOVWF  32
0606:  CALL   2FB
0607:  MOVLW  AC
0608:  BSF    03.6
0609:  MOVWF  0D
060A:  MOVLW  00
060B:  MOVWF  0F
060C:  BSF    03.0
060D:  MOVLW  04
060E:  BCF    03.6
060F:  MOVWF  31
0610:  CALL   292
....................                       output_high(o_LED_AT);  
0611:  BCF    30.7
0612:  MOVF   30,W
0613:  BSF    03.5
0614:  MOVWF  07
0615:  BCF    03.5
0616:  BSF    07.7
....................                       delay_ms(500); 
0617:  MOVLW  02
0618:  MOVWF  31
0619:  MOVLW  FA
061A:  MOVWF  37
061B:  CALL   132
061C:  DECFSZ 31,F
061D:  GOTO   619
....................                       limpar(); 
061E:  CALL   241
....................                       printf(LCD_PUTC, "1:OK, 2:OK, 3:OK,  \n 4:OK"); 
061F:  MOVLW  AF
0620:  BSF    03.6
0621:  MOVWF  0D
0622:  MOVLW  00
0623:  MOVWF  0F
0624:  BCF    03.6
0625:  CALL   247
....................                       delay_ms(500); 
0626:  MOVLW  02
0627:  MOVWF  31
0628:  MOVLW  FA
0629:  MOVWF  37
062A:  CALL   132
062B:  DECFSZ 31,F
062C:  GOTO   628
....................                       estado=5; 
062D:  MOVLW  05
062E:  MOVWF  2A
....................                       break; 
062F:  GOTO   692
....................                 
....................                    }else if((at>=0)&&(at<=6)){  // alcalinidade baixa pisca 6 vezes 
0630:  GOTO   68E
0631:  MOVF   2C,W
0632:  SUBLW  06
0633:  BTFSS  03.0
0634:  GOTO   662
....................                             limpar(); 
0635:  CALL   241
....................                             printf(LCD_PUTC, "AT BAIXA:  %u   \n",at); 
0636:  MOVLW  BC
0637:  BSF    03.6
0638:  MOVWF  0D
0639:  MOVLW  00
063A:  MOVWF  0F
063B:  BCF    03.0
063C:  MOVLW  0B
063D:  BCF    03.6
063E:  MOVWF  31
063F:  CALL   292
0640:  MOVF   2C,W
0641:  MOVWF  31
0642:  MOVLW  1B
0643:  MOVWF  32
0644:  CALL   2FB
0645:  MOVLW  C2
0646:  BSF    03.6
0647:  MOVWF  0D
0648:  MOVLW  00
0649:  MOVWF  0F
064A:  BSF    03.0
064B:  MOVLW  04
064C:  BCF    03.6
064D:  MOVWF  31
064E:  CALL   292
....................                             output_high(o_LED_AT);  
064F:  BCF    30.7
0650:  MOVF   30,W
0651:  BSF    03.5
0652:  MOVWF  07
0653:  BCF    03.5
0654:  BSF    07.7
....................                             delay_ms(100); 
0655:  MOVLW  64
0656:  MOVWF  37
0657:  CALL   132
....................                             output_low(o_LED_AT);  
0658:  BCF    30.7
0659:  MOVF   30,W
065A:  BSF    03.5
065B:  MOVWF  07
065C:  BCF    03.5
065D:  BCF    07.7
....................                             delay_ms(100); 
065E:  MOVLW  64
065F:  MOVWF  37
0660:  CALL   132
....................                     
....................                          } else{// alcalinidade alta 
0661:  GOTO   68E
....................                               limpar(); 
0662:  CALL   241
....................                               printf(LCD_PUTC, "AT ALTA:  %u   \n",at); 
0663:  MOVLW  C5
0664:  BSF    03.6
0665:  MOVWF  0D
0666:  MOVLW  00
0667:  MOVWF  0F
0668:  BCF    03.0
0669:  MOVLW  0A
066A:  BCF    03.6
066B:  MOVWF  31
066C:  CALL   292
066D:  MOVF   2C,W
066E:  MOVWF  31
066F:  MOVLW  1B
0670:  MOVWF  32
0671:  CALL   2FB
0672:  MOVLW  CB
0673:  BSF    03.6
0674:  MOVWF  0D
0675:  MOVLW  00
0676:  MOVWF  0F
0677:  BCF    03.0
0678:  MOVLW  04
0679:  BCF    03.6
067A:  MOVWF  31
067B:  CALL   292
....................                               output_high(o_LED_AT);  
067C:  BCF    30.7
067D:  MOVF   30,W
067E:  BSF    03.5
067F:  MOVWF  07
0680:  BCF    03.5
0681:  BSF    07.7
....................                               delay_ms(100); 
0682:  MOVLW  64
0683:  MOVWF  37
0684:  CALL   132
....................                               output_low(o_LED_AT);  
0685:  BCF    30.7
0686:  MOVF   30,W
0687:  BSF    03.5
0688:  MOVWF  07
0689:  BCF    03.5
068A:  BCF    07.7
....................                               delay_ms(100); 
068B:  MOVLW  64
068C:  MOVWF  37
068D:  CALL   132
....................                            } 
....................                 at = le_A0(); 
068E:  CALL   3E1
068F:  MOVF   78,W
0690:  MOVWF  2C
0691:  GOTO   5E7
....................                } 
....................            limpar(); 
0692:  CALL   241
....................            break; 
0693:  GOTO   7DF
....................             
....................            
....................            //Estado 5 - Verifica o ph da agua, o teor ideal de pH  entre 7,2 e 7,6. Caso esteja abaixo, adicione Elevador de pH. Caso esteja acima, adicione Redutor de pH. 
....................             
....................            case 5: 
....................                  
....................               printf(LCD_PUTC, "LENDO SENSOR PH  \n"); 
0694:  MOVLW  CE
0695:  BSF    03.6
0696:  MOVWF  0D
0697:  MOVLW  00
0698:  MOVWF  0F
0699:  BCF    03.6
069A:  CALL   247
....................               delay_ms(500); 
069B:  MOVLW  02
069C:  MOVWF  31
069D:  MOVLW  FA
069E:  MOVWF  37
069F:  CALL   132
06A0:  DECFSZ 31,F
06A1:  GOTO   69D
....................               ph = le_A1(); 
06A2:  CALL   411
06A3:  MOVF   78,W
06A4:  MOVWF  2D
....................               limpar(); 
06A5:  CALL   241
....................               while((ph!=5)||(ph!=6)||(ph!=7)){ 
06A6:  MOVF   2D,W
06A7:  SUBLW  05
06A8:  BTFSS  03.2
06A9:  GOTO   6B2
06AA:  MOVF   2D,W
06AB:  SUBLW  06
06AC:  BTFSS  03.2
06AD:  GOTO   6B2
06AE:  MOVF   2D,W
06AF:  SUBLW  07
06B0:  BTFSC  03.2
06B1:  GOTO   75D
....................                 
....................                 if((ph>=0)&&(ph<=4)){  // PH baixo 
06B2:  MOVF   2D,W
06B3:  SUBLW  04
06B4:  BTFSS  03.0
06B5:  GOTO   6E5
....................                      limpar(); 
06B6:  CALL   241
....................                      printf(LCD_PUTC, "PH BAIXO:  %u   \n",ph); 
06B7:  MOVLW  D8
06B8:  BSF    03.6
06B9:  MOVWF  0D
06BA:  MOVLW  00
06BB:  MOVWF  0F
06BC:  BCF    03.0
06BD:  MOVLW  0B
06BE:  BCF    03.6
06BF:  MOVWF  31
06C0:  CALL   292
06C1:  MOVF   2D,W
06C2:  MOVWF  31
06C3:  MOVLW  1B
06C4:  MOVWF  32
06C5:  CALL   2FB
06C6:  MOVLW  DE
06C7:  BSF    03.6
06C8:  MOVWF  0D
06C9:  MOVLW  00
06CA:  MOVWF  0F
06CB:  BSF    03.0
06CC:  MOVLW  04
06CD:  BCF    03.6
06CE:  MOVWF  31
06CF:  CALL   292
....................                      output_high(o_LED_PH);  
06D0:  BCF    30.1
06D1:  MOVF   30,W
06D2:  BSF    03.5
06D3:  MOVWF  07
06D4:  BCF    03.5
06D5:  BSF    07.1
....................                      delay_ms(100); 
06D6:  MOVLW  64
06D7:  MOVWF  37
06D8:  CALL   132
....................                      output_low(o_LED_PH);  
06D9:  BCF    30.1
06DA:  MOVF   30,W
06DB:  BSF    03.5
06DC:  MOVWF  07
06DD:  BCF    03.5
06DE:  BCF    07.1
....................                      delay_ms(100); 
06DF:  MOVLW  64
06E0:  MOVWF  37
06E1:  CALL   132
....................                      estado=6; 
06E2:  MOVLW  06
06E3:  MOVWF  2A
....................                  
....................                }else if((ph==5)||(ph==6)||(ph==7)){ // ph ideal 
06E4:  GOTO   759
06E5:  MOVF   2D,W
06E6:  SUBLW  05
06E7:  BTFSC  03.2
06E8:  GOTO   6F1
06E9:  MOVF   2D,W
06EA:  SUBLW  06
06EB:  BTFSC  03.2
06EC:  GOTO   6F1
06ED:  MOVF   2D,W
06EE:  SUBLW  07
06EF:  BTFSS  03.2
06F0:  GOTO   72B
....................                         limpar(); 
06F1:  CALL   241
....................                         printf(LCD_PUTC, "PH IDEAL:  %u   \n",ph); 
06F2:  MOVLW  E1
06F3:  BSF    03.6
06F4:  MOVWF  0D
06F5:  MOVLW  00
06F6:  MOVWF  0F
06F7:  BCF    03.0
06F8:  MOVLW  0B
06F9:  BCF    03.6
06FA:  MOVWF  31
06FB:  CALL   292
06FC:  MOVF   2D,W
06FD:  MOVWF  31
06FE:  MOVLW  1B
06FF:  MOVWF  32
0700:  CALL   2FB
0701:  MOVLW  E7
0702:  BSF    03.6
0703:  MOVWF  0D
0704:  MOVLW  00
0705:  MOVWF  0F
0706:  BSF    03.0
0707:  MOVLW  04
0708:  BCF    03.6
0709:  MOVWF  31
070A:  CALL   292
....................                         output_high(o_LED_PH);  
070B:  BCF    30.1
070C:  MOVF   30,W
070D:  BSF    03.5
070E:  MOVWF  07
070F:  BCF    03.5
0710:  BSF    07.1
....................                         delay_ms(500); 
0711:  MOVLW  02
0712:  MOVWF  31
0713:  MOVLW  FA
0714:  MOVWF  37
0715:  CALL   132
0716:  DECFSZ 31,F
0717:  GOTO   713
....................                         limpar(); 
0718:  CALL   241
....................                         printf(LCD_PUTC, "1:OK, 2:OK, 3:OK,   \n  4:OK, 5:OK "); 
0719:  MOVLW  EA
071A:  BSF    03.6
071B:  MOVWF  0D
071C:  MOVLW  00
071D:  MOVWF  0F
071E:  BCF    03.6
071F:  CALL   247
....................                         delay_ms(500); 
0720:  MOVLW  02
0721:  MOVWF  31
0722:  MOVLW  FA
0723:  MOVWF  37
0724:  CALL   132
0725:  DECFSZ 31,F
0726:  GOTO   722
....................                         estado=6; 
0727:  MOVLW  06
0728:  MOVWF  2A
....................                         break;  
0729:  GOTO   75D
....................                       
....................                       } else{// PH alto 
072A:  GOTO   759
....................                             limpar(); 
072B:  CALL   241
....................                             printf(LCD_PUTC, "PH ALTO:  %u   \n",ph); 
072C:  MOVLW  FC
072D:  BSF    03.6
072E:  MOVWF  0D
072F:  MOVLW  00
0730:  MOVWF  0F
0731:  BCF    03.0
0732:  MOVLW  0A
0733:  BCF    03.6
0734:  MOVWF  31
0735:  CALL   292
0736:  MOVF   2D,W
0737:  MOVWF  31
0738:  MOVLW  1B
0739:  MOVWF  32
073A:  CALL   2FB
073B:  MOVLW  02
073C:  BSF    03.6
073D:  MOVWF  0D
073E:  MOVLW  01
073F:  MOVWF  0F
0740:  BCF    03.0
0741:  MOVLW  04
0742:  BCF    03.6
0743:  MOVWF  31
0744:  CALL   292
....................                             output_high(o_LED_PH);  
0745:  BCF    30.1
0746:  MOVF   30,W
0747:  BSF    03.5
0748:  MOVWF  07
0749:  BCF    03.5
074A:  BSF    07.1
....................                             delay_ms(100); 
074B:  MOVLW  64
074C:  MOVWF  37
074D:  CALL   132
....................                             output_low(o_LED_PH);  
074E:  BCF    30.1
074F:  MOVF   30,W
0750:  BSF    03.5
0751:  MOVWF  07
0752:  BCF    03.5
0753:  BCF    07.1
....................                             delay_ms(100); 
0754:  MOVLW  64
0755:  MOVWF  37
0756:  CALL   132
....................                             estado=6; 
0757:  MOVLW  06
0758:  MOVWF  2A
....................                      } 
....................                 
....................                ph = le_A1(); 
0759:  CALL   411
075A:  MOVF   78,W
075B:  MOVWF  2D
075C:  GOTO   6A6
....................                  
....................               } 
....................             
....................             limpar(); 
075D:  CALL   241
....................             break; 
075E:  GOTO   7DF
....................             
....................             
....................            // Estado 6: Verifica a porcentagem de cloro. O teor ideal de cloro  entre 1 e 3 ppm. Caso esteja abaixo aplica o produto na piscina. 
....................             case 6: 
....................                cl = le_A2(); 
075F:  CALL   441
0760:  MOVF   78,W
0761:  MOVWF  2E
....................                limpar(); 
0762:  CALL   241
....................                while((cl!=8)||(cl!=9)){ 
0763:  MOVF   2E,W
0764:  SUBLW  08
0765:  BTFSS  03.2
0766:  GOTO   76B
0767:  MOVF   2E,W
0768:  SUBLW  09
0769:  BTFSC  03.2
076A:  GOTO   7DF
....................                 
....................                // CLORO ideal 
....................                if((cl==8)||(cl==9)){ 
076B:  MOVF   2E,W
076C:  SUBLW  08
076D:  BTFSC  03.2
076E:  GOTO   773
076F:  MOVF   2E,W
0770:  SUBLW  09
0771:  BTFSS  03.2
0772:  GOTO   7B4
....................                    printf(LCD_PUTC, "CLORO IDEAL:  %u   \n",cl); 
0773:  MOVLW  05
0774:  BSF    03.6
0775:  MOVWF  0D
0776:  MOVLW  01
0777:  MOVWF  0F
0778:  BCF    03.0
0779:  MOVLW  0E
077A:  BCF    03.6
077B:  MOVWF  31
077C:  CALL   292
077D:  MOVF   2E,W
077E:  MOVWF  31
077F:  MOVLW  1B
0780:  MOVWF  32
0781:  CALL   2FB
0782:  MOVLW  0D
0783:  BSF    03.6
0784:  MOVWF  0D
0785:  MOVLW  01
0786:  MOVWF  0F
0787:  BCF    03.0
0788:  MOVLW  04
0789:  BCF    03.6
078A:  MOVWF  31
078B:  CALL   292
....................                    delay_ms(500); 
078C:  MOVLW  02
078D:  MOVWF  31
078E:  MOVLW  FA
078F:  MOVWF  37
0790:  CALL   132
0791:  DECFSZ 31,F
0792:  GOTO   78E
....................                    limpar(); 
0793:  CALL   241
....................                    printf(LCD_PUTC, "1:OK, 2:OK, 3:OK,   \n4:OK, 5:OK, 6:OK "); 
0794:  MOVLW  10
0795:  BSF    03.6
0796:  MOVWF  0D
0797:  MOVLW  01
0798:  MOVWF  0F
0799:  BCF    03.6
079A:  CALL   247
....................                    delay_ms(500); 
079B:  MOVLW  02
079C:  MOVWF  31
079D:  MOVLW  FA
079E:  MOVWF  37
079F:  CALL   132
07A0:  DECFSZ 31,F
07A1:  GOTO   79D
....................                    output_high(o_LED_CL); 
07A2:  BSF    03.5
07A3:  BCF    08.3
07A4:  BCF    03.5
07A5:  BSF    08.3
....................                    output_low( o_VALVULA_CL); 
07A6:  BCF    30.0
07A7:  MOVF   30,W
07A8:  BSF    03.5
07A9:  MOVWF  07
07AA:  BCF    03.5
07AB:  BCF    07.0
....................                    delay_ms(200); 
07AC:  MOVLW  C8
07AD:  MOVWF  37
07AE:  CALL   132
....................                    cont++; 
07AF:  INCF   2F,F
....................                    estado=2; 
07B0:  MOVLW  02
07B1:  MOVWF  2A
....................                    break; 
07B2:  GOTO   7DF
....................                }else{ 
07B3:  GOTO   7DB
....................                    printf(LCD_PUTC, "APLIQUE MAIS CLORO:  %u   \n",cl); 
07B4:  MOVLW  24
07B5:  BSF    03.6
07B6:  MOVWF  0D
07B7:  MOVLW  01
07B8:  MOVWF  0F
07B9:  BCF    03.0
07BA:  MOVLW  15
07BB:  BCF    03.6
07BC:  MOVWF  31
07BD:  CALL   292
07BE:  MOVF   2E,W
07BF:  MOVWF  31
07C0:  MOVLW  1B
07C1:  MOVWF  32
07C2:  CALL   2FB
07C3:  MOVLW  2F
07C4:  BSF    03.6
07C5:  MOVWF  0D
07C6:  MOVLW  01
07C7:  MOVWF  0F
07C8:  BSF    03.0
07C9:  MOVLW  04
07CA:  BCF    03.6
07CB:  MOVWF  31
07CC:  CALL   292
....................                    delay_ms(500); 
07CD:  MOVLW  02
07CE:  MOVWF  31
07CF:  MOVLW  FA
07D0:  MOVWF  37
07D1:  CALL   132
07D2:  DECFSZ 31,F
07D3:  GOTO   7CF
....................                    limpar(); 
07D4:  CALL   241
....................                    output_high( o_VALVULA_CL); 
07D5:  BCF    30.0
07D6:  MOVF   30,W
07D7:  BSF    03.5
07D8:  MOVWF  07
07D9:  BCF    03.5
07DA:  BSF    07.0
....................                } 
....................             cl = le_A2(); 
07DB:  CALL   441
07DC:  MOVF   78,W
07DD:  MOVWF  2E
07DE:  GOTO   763
....................          } 
....................     
....................     
....................     
....................     
....................           
....................          } 
07DF:  GOTO   4A9
....................   } 
....................  } 
....................  
07E0:  SLEEP
....................  
....................  
....................  
....................  

Configuration Fuses:
   Word  1: 3F3D   XT WDT NOPUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
